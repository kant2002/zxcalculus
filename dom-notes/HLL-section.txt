Title: High-level languages for quantum computing

Everything we’ve talked about up to now has been at the qubit level (either raw or error corrected). As quantum computers get bigger (and even now), we will need “high-level” languages capable of dealing with huge numbers of qubits. In circuit notation, for example, even small algorithms with a few tens of qubits can quickly become unreadable, making optimisation and verification difficult or impossible, let alone algorithm design.

This is one time when gluing your LEGO together really is useful. 
Unlike every other qubit representation, ZX comes equipped with two systematic ways of making this jump to a multi-qubit high-level language. These work in specific situations: when there are repeated structures or subroutines within an algorithm. The methods can be used to represent potentially arbitrarily many qubits, all on a single easily-readable diagram. These two tools are !-boxes and the “scalable” ZX calculus. They have applications in circuit optimisation tools and algorithm design (especially for quantum error correction). They can be used either separately or together.

 !-boxes are [insert favourite technical short description of them]. In LEGO terms, they’re the equivalent of the instruction “build this particular structure n times and connect them on in this way” [figure]. They are used for [insert favourite use-case]. This has the potential to [insert favourite what-next]. 

The scalable ZX calculus is a complementary way of dealing with large numbers of qubits and operations. This adds to the standard ZX operations the ability to bundle together many wires to make one thick wire. Connections between thick wires are then given by binary matrices (biadjacency matrices of zeros and ones) that tell you which wires within one bundle are connected to which in another bundle [figure]. Formally, [SZX paper stuff]. This combination of thick wires and simple binary matrices can again represent arbitrarily many qubits when all the operations between them are the same. One particular example of such repeated structures is the phase gadgets of section N. These are easy to represent in the scalable calculus at any size, making them much easier to deal with at large scales [figure].
Another place the scalable calculus is ideal is quantum error correction codes. These are made up of continually repeated structures which are themselves comprised of repeated identical operations between different qubits. In fact, all (stabilizer) codes can be represented by a single scalableZX diagram [figure], no matter how many qubits are involved (the code “distance”) or what code it is. Both these pieces of information are given by the simple binary matrices (here, A, B, and C). [can end this sentence after "diagram" and not give this example in detail, just give the paper reference]. 
These types of repeated operation structures are also found much more widely in quantum algorithms. Two important current examples are the repeated sets of cascading CNOTs in the quantum Fourier transform, and in adder circuits for quantum arithmetic. 
The re-write rules for ZX including those for !-boxes and scalable wires/matrices are also complete. This means we can use them for re-writing any sized diagram as long as it has relevant structure. In fact the basic tools of the scalable calculus have been formalised to work with any of the zoo of graphical calculi that have come out of the ZX project. 
In the future, integrating these many-qubit representations will let the graphical tools we have scale with the size of quantum computers as they get larger, both in the initial NISQ regime, and eventually the ultimate aim of large-scale fully fault-tolerant quantum computing. Through them, ZX can finally unlock real multi-qubit high-level languages for quantum computing. 
